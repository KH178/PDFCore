/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Represents a shaped glyph with position and advance information */
export interface ShapedGlyph {
  glyphId: number
  xAdvance: number
  yAdvance: number
  xOffset: number
  yOffset: number
}
/**
 * Column definition for Table
 * Color structure (RGB/RGBA)
 */
export interface Color {
  r: number
  g: number
  b: number
  a?: number
}
/** Template for repeating headers and footers */
export interface Template {
  marginTop?: number
  marginBottom?: number
}
export interface TableColumn {
  header: string
  width: number
  align?: string
}
/** Represents a loaded font with parsing and shaping capabilities */
export declare class Font {
  /** Load a font from a file path */
  static fromFile(path: string, name: string): Font
  /** Load a font from bytes (e.g., embedded font data) */
  static fromBytes(data: Array<number>, name: string): Font
  /** Measure text width using shaping */
  measureText(text: string, size: number): number
  /** Shape text and return glyph IDs with positions */
  shapeText(text: string, size: number): Array<ShapedGlyph>
}
/** Represents a loaded image (JPEG or PNG) */
export declare class Image {
  /** Load an image from a file path */
  static fromFile(path: string): Image
}
/** Data Table with headers and rows */
export declare class Table {
  constructor(columns: Array<TableColumn>)
  addRow(row: Array<string>): void
  setFontSize(size: number): void
}
/** Opaque wrapper for a Layout Node */
export declare class LayoutNode {
  /** Create a Column node */
  static column(children: Array<LayoutNode>, spacing?: number | undefined | null): LayoutNode
  static row(children: Array<LayoutNode>, spacing?: number | undefined | null): LayoutNode
  static text(text: string, size: number, color?: Color | undefined | null, backgroundColor?: Color | undefined | null): LayoutNode
  static container(child: LayoutNode, padding?: number | undefined | null, border?: number | undefined | null): LayoutNode
  static image(imageIndex: number, width: number, height: number): LayoutNode
  static table(table: Table): LayoutNode
  static pageNumber(format: string, size: number, align?: string | undefined | null): LayoutNode
}
/** Represents a single page in a PDF document */
export declare class Page {
  /** Create a new page with specified dimensions */
  constructor(width: number, height: number)
  /** Add text to the page using built-in font (Helvetica) */
  text(text: string, x: number, y: number, size: number): this
  /** Add multiline text with wrapping */
  textMultiline(text: string, x: number, y: number, width: number, size: number, fontIndex: number, font: Font): this
  /** Add text using a custom font (by index) */
  textWithFont(text: string, x: number, y: number, size: number, fontIndex: number, font: Font): this
  /** Draw a line */
  drawLine(x1: number, y1: number, x2: number, y2: number, width: number): this
  /** Draw a rectangle (stroke) */
  drawRect(x: number, y: number, w: number, h: number, width: number): this
  /** Draw a filled rectangle (gray) */
  drawFillRect(x: number, y: number, w: number, h: number, gray: number): this
  /** Draw a table */
  drawTable(table: Table, x: number, y: number, font: Font, fontIndex: number): number
  /** Draw an image */
  drawImage(imageIndex: number, x: number, y: number, width: number, height: number): this
  /** Render a declarative layout tree */
  renderLayout(node: LayoutNode, x: number, y: number, width: number, font: Font, fontIndex: number, currentPage?: number | undefined | null, totalPages?: number | undefined | null): void
}
/** Represents a PDF document with multiple pages */
export declare class Document {
  /** Create a new empty document in buffered mode */
  constructor()
  /**
   * Create a new document in streaming mode
   * Pages are written immediately as they're added
   */
  static streaming(path: string): Document
  /**
   * Register a custom font with the document
   * Returns the font index to use in page rendering
   */
  addFont(font: Font): number
  /**
   * Register an image with the document
   * Returns the image index to use in page rendering
   */
  addImage(image: Image): number
  /** Add a page to the document */
  addPage(page: Page): void
  /** Finalize a streaming document */
  finalize(): void
  /** Write the document to a file (buffered mode) */
  writeTo(path: string): void
  /** Automatically paginate a layout tree across multiple pages */
  renderFlow(node: LayoutNode, width: number, height: number, font: Font, fontIndex: number, header?: LayoutNode | undefined | null, footer?: LayoutNode | undefined | null, template?: Template | undefined | null): void
}
